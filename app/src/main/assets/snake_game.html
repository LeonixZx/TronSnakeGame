<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Snake Game by LeonCybr Lab</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">

    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        @keyframes glowingEffect {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.7; }
        }

        @keyframes sparkle {
            0%, 100% { opacity: 0; transform: scale(0.5); }
            50% { opacity: 1; transform: scale(1); }
        }

        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif, 'Orbitron';
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            position: relative;
        }

        body::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: url('background_interface.jpg');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            background-attachment: fixed;
            z-index: -2;
        }

        body::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg,
                        rgba(26, 26, 46, 0.5),
                        rgba(22, 33, 62, 0.5),
                        rgba(15, 52, 96, 0.5),
                        rgba(37, 40, 80, 0.5));
            background-size: 400% 400%;
            animation: glowingEffect 8s ease infinite;
            z-index: -1;
        }

        .sparkle {
            position: absolute;
            width: 3px;
            height: 3px;
            border-radius: 50%;
            background-color: white;
            box-shadow: 0 0 10px 1px white;
            animation: sparkle 1.5s infinite;
            pointer-events: none;
            z-index: 1;
        }

        .container {
            width: 100%;
            max-width: 600px;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
            background-color: rgba(30, 36, 48, 0.7);
            padding: 20px;
            border-radius: 10px;
            margin: 20px auto;
        }

        #author {
            text-align: center;
            margin: 20px 0;
        }

        .snake-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 48px;
            color: #ffffff;
            margin: 0;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.9);
        }

        .author-name {
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            color: #a0a0a0;
        }

        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            background-color: rgba(0, 0, 0, 0.7);
            border-bottom-left-radius: 10px;
            border-bottom-right-radius: 10px;
        }

        .btn {
            background-color: #5cffe7;
            color: #000000;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Orbitron', sans-serif;
            box-shadow: 0 0 10px rgba(92, 255, 231, 0.7);
        }

        .btn:hover {
            background-color: #00ffff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.9);
        }

        #startPauseButton {
            background-color: rgba(76, 255, 215, 0.8);
            color: #1e2430;
        }

        #startPauseButton:hover {
            background-color: rgba(76, 255, 215, 1);
        }

        #musicToggle {
            background-color: #808080;
            color: #ffffff;
            font-size: 20px;
            padding: 5px 10px;
        }

        #canvas {
            width: 100%;
            aspect-ratio: 1 / 1;
            max-width: 400px;
            max-height: 400px;
            border: 2px solid #34495e;
            border-radius: 5px;
            background-image: url('https://t3.ftcdn.net/jpg/04/71/00/20/360_F_471002062_tCBbTqeeMhHgMfCW86mQhdgpETooy3ID.jpg');
            background-size: cover;
            background-position: center;
            position: relative;
        }

        .game-container {
            position: relative;
            width: 100%;
            max-width: 400px;
            margin: 0 auto;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            overflow: hidden;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            padding: 10px 20px;
            background-color: rgba(0, 0, 0, 0.7);
        }

        #score, #timer {
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            color: #5cffe7;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(92, 255, 231, 0.7);
        }

        .controller {
            position: absolute;
            bottom: 5vh;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
        }

        .controller-handle {
            position: absolute;
            top: -20px;
            left: -20px;
            width: 40px;
            height: 40px;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            cursor: move;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .controller-handle::before {
            content: '';
            width: 20px;
            height: 20px;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="white"><path d="M7 10l5-5 5 5M7 14l5 5 5-5"/></svg>');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            opacity: 0.7;
        }

        .control-area {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr 1fr;
            gap: 5%;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            padding: 5%;
            box-sizing: border-box;
        }

        #upBtn { grid-area: 1 / 2 / 2 / 3; }
        #leftBtn { grid-area: 2 / 1 / 3 / 2; }
        #rightBtn { grid-area: 2 / 3 / 3 / 4; }
        #downBtn { grid-area: 3 / 2 / 4 / 3; }

        .control-btn {
            background-color: rgba(255, 255, 255, 0.8);
            border: none;
            border-radius: 50%;
            width: 100%;
            height: 0;
            padding-bottom: 100%;
            position: relative;
            font-size: 0;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            outline: none;
        }

        .control-btn::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50%;
            height: 50%;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            font-size: 24px;
        }

        #upBtn::after { content: '‚¨ÜÔ∏è'; }
        #downBtn::after { content: '‚¨áÔ∏è'; }
        #leftBtn::after { content: '‚¨ÖÔ∏è'; }
        #rightBtn::after { content: '‚û°Ô∏è'; }

        .control-btn:hover, .control-btn:active, .control-btn.active {
            background-color: rgba(76, 255, 215, 1);
            transform: scale(1.1);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        #gameOver, #leaderboard {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(30, 36, 48, 0.95);
            padding: 20px;
            border-radius: 10px;
            display: none;
            color: #ffffff;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            max-width: 90%;
            width: 300px;
        }

        #playerName {
            margin: 10px 0;
            padding: 5px;
            width: 100%;
            max-width: 100%;
        }

        #submitScore, #closeLeaderboard {
            background: #4cffd7;
            border: none;
            padding: 8px 15px;
            cursor: pointer;
            color: #1e2430;
            font-weight: bold;
            border-radius: 5px;
            transition: background-color 0.3s;
            width: 100%;
            margin-top: 10px;
        }

        #submitScore:hover, #closeLeaderboard:hover {
            background: #3de0b8;
        }

        #leaderboardList {
            list-style-type: none;
            padding: 0;
            margin: 20px 0;
            text-align: left;
        }

        #leaderboardList li {
            margin: 10px 0;
            padding: 5px;
            background: rgba(76, 255, 215, 0.1);
            border-radius: 3px;
        }

        #leaderboard h2, #gameOver h2 {
            color: #4cffd7;
            margin-top: 0;
            text-align: center;
        }

        .leaderboard-header {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            background-color: rgba(76, 255, 215, 0.2);
            font-weight: bold;
            border-radius: 5px 5px 0 0;
        }

        .leaderboard-row {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .leaderboard-cell {
            flex: 1;
            text-align: center;
        }

        @media (max-width: 600px) {
            .controller {
                width: 35vmin;
                height: 35vmin;
            }

            .control-btn::after {
                font-size: 5vmin;
            }

            .controls {
                flex-wrap: wrap;
                justify-content: center;
            }

            .controls > * {
                margin: 5px;
            }

            #canvas {
                max-width: 90vw;
                max-height: 90vw;
            }
        }
    </style>
</head>
<body>
<div class="container noselect">
    <div id="author">
        <h2 class="snake-title">Tron Snake</h2>
        <span class="author-name">by LeonCybr Lab</span>
    </div>
    <div class="game-container">
        <div class="game-info">
            <div id="score">Score: 00</div>
            <div id="timer">00:00</div>
        </div>
        <div id="canvas">
            <canvas></canvas>
        </div>
        <div class="controls">
            <button id="startPauseButton" class="btn">Start</button>
            <button id="musicToggle" class="btn">üîä</button>
        </div>
    </div>

    <div class="controller">
        <div id="controlArea" class="control-area">
            <button id="upBtn" class="control-btn" data-direction="ArrowUp"></button>
            <button id="leftBtn" class="control-btn" data-direction="ArrowLeft"></button>
            <button id="rightBtn" class="control-btn" data-direction="ArrowRight"></button>
            <button id="downBtn" class="control-btn" data-direction="ArrowDown"></button>
        </div>
    </div>
</div>
<div id="gameOver">
    <h2>GAME OVER</h2>
    <p>Your score: <span id="finalScore"></span></p>
    <p>Your time: <span id="finalTime"></span></p>
    <input type="text" id="playerName" placeholder="Enter your name (max 20 chars)" maxlength="20">
    <button id="submitScore">Submit Score</button>
</div>
<div id="leaderboard">
    <h2>üèÜ Leaderboard üèÜ</h2>
    <div class="leaderboard-header">
        <div class="leaderboard-cell">Rank</div>
        <div class="leaderboard-cell">Name</div>
        <div class="leaderboard-cell">Score</div>
        <div class="leaderboard-cell">Time</div>
    </div>
    <ul id="leaderboardList"></ul>
    <button id="closeLeaderboard">Close</button>
</div>

<script>
    let dom_startPauseButton = document.querySelector("#startPauseButton");
    let dom_score = document.querySelector("#score");
    let dom_timer = document.querySelector("#timer");
    let dom_canvas = document.querySelector("canvas");
    let CTX = dom_canvas.getContext("2d");

    let W, H;

    let snake,
        food,
        currentHue,
        cells = 20,
        cellSize,
        isGameOver = false,
        tails = [],
        score = 00,
        maxScore = window.localStorage.getItem("maxScore") || undefined,
        particles = [],
        splashingParticleCount = 20,
        cellsCount,
        requestID;

    let isGameStarted = false;
    let isPaused = false;
    let startTime;
    let elapsedTime = 0;
    let timerInterval;

    let lights = [];
    const NUM_LIGHTS = 5;

    let meteorSpawnTime = 0;
    const METEOR_SPAWN_DELAY = 15000; // 15 seconds in milliseconds
    let meteors = [];
    let meteorSpawnTimers = []; // Array to keep track of spawn times for each meteor
    let shouldSpawnMeteors = false;

    let helpers = {
        Vec: class {
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }
            add(v) {
                this.x += v.x;
                this.y += v.y;
                return this;
            }
            mult(v) {
                if (v instanceof helpers.Vec) {
                    this.x *= v.x;
                    this.y *= v.y;
                    return this;
                } else {
                    this.x *= v;
                    this.y *= v;
                    return this;
                }
            }
        },
        isCollision(v1, v2) {
            return Math.abs(v1.x - v2.x) < cellSize / 2 && Math.abs(v1.y - v2.y) < cellSize / 2;
        },
        isCollisionCircle(v1, v2, r1, r2) {
            const dx = v1.x - v2.x;
            const dy = v1.y - v2.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < (r1 + r2);
        },
        garbageCollector() {
            for (let i = 0; i < particles.length; i++) {
                if (particles[i].size <= 0) {
                    particles.splice(i, 1);
                }
            }
        },
        drawGrid() {
            CTX.lineWidth = 1.1;
            CTX.strokeStyle = "rgba(255, 255, 255, 0.1)";
            CTX.shadowBlur = 0;
            for (let i = 1; i < cells; i++) {
                let f = (W / cells) * i;
                CTX.beginPath();
                CTX.moveTo(f, 0);
                CTX.lineTo(f, H);
                CTX.stroke();
                CTX.beginPath();
                CTX.moveTo(0, f);
                CTX.lineTo(W, f);
                CTX.stroke();
                CTX.closePath();
            }
        },
        randHue() {
            return ~~(Math.random() * 360);
        },
        hsl2rgb(hue, saturation, lightness) {
            if (hue == undefined) {
                return [0, 0, 0];
            }
            var chroma = (1 - Math.abs(2 * lightness - 1)) * saturation;
            var huePrime = hue / 60;
            var secondComponent = chroma * (1 - Math.abs((huePrime % 2) - 1));

            huePrime = ~~huePrime;
            var red;
            var green;
            var blue;

            if (huePrime === 0) {
                red = chroma;
                green = secondComponent;
                blue = 0;
            } else if (huePrime === 1) {
                red = secondComponent;
                green = chroma;
                blue = 0;
            } else if (huePrime === 2) {
                red = 0;
                green = chroma;
                blue = secondComponent;
            } else if (huePrime === 3) {
                red = 0;
                green = secondComponent;
                blue = chroma;
            } else if (huePrime === 4) {
                red = secondComponent;
                green = 0;
                blue = chroma;
            } else if (huePrime === 5) {
                red = chroma;
                green = 0;
                blue = secondComponent;
            }

            var lightnessAdjustment = lightness - chroma / 2;
            red += lightnessAdjustment;
            green += lightnessAdjustment;
            blue += lightnessAdjustment;

            return [
                Math.round(red * 255),
                Math.round(green * 255),
                Math.round(blue * 255)
            ];
        },
        lerp(start, end, t) {
            return start * (1 - t) + end * t;
        }
    };

    let KEY = {
        ArrowUp: false,
        ArrowRight: false,
        ArrowDown: false,
        ArrowLeft: false,
        Shift: false,
        lastPressed: null,
        setLastPressed(key) {
            this.lastPressed = key;
            console.log("Direction changed to:", key); // For debugging
        },
        resetState() {
            this.ArrowUp = false;
            this.ArrowRight = false;
            this.ArrowDown = false;
            this.ArrowLeft = false;
            this.lastPressed = null;
        },
        listen() {
            addEventListener(
                "keydown",
                (e) => {
                    if (e.key === "Shift") {
                        this.Shift = true;
                        return;
                    }
                    if (!isGameStarted || isPaused) return;
                    if (e.key === "ArrowUp" && this.lastPressed !== "ArrowDown") this.lastPressed = "ArrowUp";
                    if (e.key === "ArrowDown" && this.lastPressed !== "ArrowUp") this.lastPressed = "ArrowDown";
                    if (e.key === "ArrowLeft" && this.lastPressed !== "ArrowRight") this.lastPressed = "ArrowLeft";
                    if (e.key === "ArrowRight" && this.lastPressed !== "ArrowLeft") this.lastPressed = "ArrowRight";
                },
                false
            );

            addEventListener(
                "keyup",
                (e) => {
                    if (e.key === "Shift") {
                        this.Shift = false;
                    }
                },
                false
            );
        }
    };

    class Snake {
        constructor(i, type) {
            this.pos = new helpers.Vec(W / 2, H / 2);
            this.dir = new helpers.Vec(0, 0);
            this.type = type;
            this.index = i;
            this.delay = 5;
            this.size = W / cells;
            this.color = "white";
            this.history = [];
            this.total = 1;
            this.baseHue = 200;
            this.eyeSize = this.size / 8;
            this.tongueLength = this.size / 3;
            this.tongueOut = false;
            this.tongueTimer = 0;
            this.tongueInterval = 10;
            this.queuedDirection = null;
            this.baseDelay = 5;
            this.speedLevel = 0;
        }

        draw() {
            if (this.total >= 2) {
                for (let i = 0; i < this.history.length; i++) {
                    let { x, y } = this.history[i];
                    let segmentSize = this.size * (1 - i / (this.history.length * 1.5));
                    let hue = this.baseHue + i * 2;
                    CTX.fillStyle = `hsl(${hue}, 100%, 50%)`;
                    CTX.beginPath();
                    CTX.arc(x + this.size / 2, y + this.size / 2, segmentSize / 2, 0, 2 * Math.PI);
                    CTX.fill();
                }
            }

            CTX.fillStyle = `hsl(${this.baseHue}, 100%, 50%)`;
            CTX.shadowBlur = 20;
            CTX.shadowColor = "rgba(255,255,255,.3)";
            CTX.beginPath();
            CTX.arc(this.pos.x + this.size / 2, this.pos.y + this.size / 2, this.size / 2, 0, 2 * Math.PI);
            CTX.fill();

            CTX.fillStyle = "white";
            CTX.shadowBlur = 0;

            let leftEyeX, leftEyeY, rightEyeX, rightEyeY;
            if (this.dir.x === 0 && this.dir.y === 0) {
                leftEyeX = this.pos.x + this.size * 0.7;
                leftEyeY = this.pos.y + this.size * 0.3;
                rightEyeX = this.pos.x + this.size * 0.7;
                rightEyeY = this.pos.y + this.size * 0.7;
            } else if (this.dir.x > 0) {
                leftEyeX = this.pos.x + this.size * 0.7;
                leftEyeY = this.pos.y + this.size * 0.3;
                rightEyeX = this.pos.x + this.size * 0.7;
                rightEyeY = this.pos.y + this.size * 0.7;
            } else if (this.dir.x < 0) {
                leftEyeX = this.pos.x + this.size * 0.3;
                leftEyeY = this.pos.y + this.size * 0.3;
                rightEyeX = this.pos.x + this.size * 0.3;
                rightEyeY = this.pos.y + this.size * 0.7;
            } else if (this.dir.y < 0) {
                leftEyeX = this.pos.x + this.size * 0.3;
                leftEyeY = this.pos.y + this.size * 0.3;
                rightEyeX = this.pos.x + this.size * 0.7;
                rightEyeY = this.pos.y + this.size * 0.3;
            } else if (this.dir.y > 0) {
                leftEyeX = this.pos.x + this.size * 0.3;
                leftEyeY = this.pos.y + this.size * 0.7;
                rightEyeX = this.pos.x + this.size * 0.7;
                rightEyeY = this.pos.y + this.size * 0.7;
            }

            CTX.beginPath();
            CTX.arc(leftEyeX, leftEyeY, this.eyeSize, 0, 2 * Math.PI);
            CTX.arc(rightEyeX, rightEyeY, this.eyeSize, 0, 2 * Math.PI);
            CTX.fill();

            CTX.fillStyle = "black";
            CTX.beginPath();
            CTX.arc(leftEyeX, leftEyeY, this.eyeSize / 2, 0, 2 * Math.PI);
            CTX.arc(rightEyeX, rightEyeY, this.eyeSize / 2, 0, 2 * Math.PI);
            CTX.fill();

            if (this.tongueOut) {
                CTX.strokeStyle = "red";
                CTX.lineWidth = this.size / 10;
                CTX.beginPath();
                if (this.dir.x > 0) {
                    CTX.moveTo(this.pos.x + this.size, this.pos.y + this.size / 2);
                    CTX.lineTo(this.pos.x + this.size + this.tongueLength, this.pos.y + this.size / 2);
                } else if (this.dir.x < 0) {
                    CTX.moveTo(this.pos.x, this.pos.y + this.size / 2);
                    CTX.lineTo(this.pos.x - this.tongueLength, this.pos.y + this.size / 2);
                } else if (this.dir.y < 0) {
                    CTX.moveTo(this.pos.x + this.size / 2, this.pos.y);
                    CTX.lineTo(this.pos.x + this.size / 2, this.pos.y - this.tongueLength);
                } else if (this.dir.y > 0) {
                    CTX.moveTo(this.pos.x + this.size / 2, this.pos.y + this.size);
                    CTX.lineTo(this.pos.x + this.size / 2, this.pos.y + this.size + this.tongueLength);
                }
                CTX.stroke();
            }
        }

        walls() {
            let { x, y } = this.pos;
            if (x + cellSize > W) {
                this.pos.x = 0;
            }
            if (y + cellSize > H) {  // Changed from W to H
                this.pos.y = 0;
            }
            if (y < 0) {
                this.pos.y = H - cellSize;
            }
            if (x < 0) {
                this.pos.x = W - cellSize;
            }
        }

        controlls() {
            let dir = this.size;
            if (KEY.lastPressed === "ArrowUp" && this.dir.y !== dir) this.queuedDirection = new helpers.Vec(0, -dir);
            if (KEY.lastPressed === "ArrowDown" && this.dir.y !== -dir) this.queuedDirection = new helpers.Vec(0, dir);
            if (KEY.lastPressed === "ArrowLeft" && this.dir.x !== dir) this.queuedDirection = new helpers.Vec(-dir, 0);
            if (KEY.lastPressed === "ArrowRight" && this.dir.x !== -dir) this.queuedDirection = new helpers.Vec(dir, 0);
        }

        isOppositeDirection(newDir) {
            return (this.dir.x === -newDir.x && this.dir.y === -newDir.y);
        }

        selfCollision() {
            for (let i = 1; i < this.history.length; i++) {
                let p = this.history[i];
                if (helpers.isCollision(this.pos, p)) {
                    isGameOver = true;
                    return;
                }
            }
        }

        move() {
            if (this.queuedDirection && !this.isOppositeDirection(this.queuedDirection)) {
                this.dir = this.queuedDirection;
                this.queuedDirection = null;
            }
            this.pos.x += this.dir.x;
            this.pos.y += this.dir.y;

            // Ensure the snake stays on the grid
            this.pos.x = Math.round(this.pos.x / cellSize) * cellSize;
            this.pos.y = Math.round(this.pos.y / cellSize) * cellSize;
        }

        update() {
            this.walls();
            this.controlls();
            if (!this.delay--) {
                if (helpers.isCollision(this.pos, food.pos)) {
                    incrementScore();
                    particleSplash();
                    food.spawn();
                    this.total++;
                }
                this.move();
                this.history.unshift(new helpers.Vec(this.pos.x, this.pos.y));
                if (this.history.length > this.total) {
                    this.history.pop();
                }
                this.delay = KEY.Shift ? Math.max(1, this.baseDelay - this.speedLevel - 2): Math.max(2, this.baseDelay - this.speedLevel);
            this.selfCollision();

            this.tongueTimer++;
            if (this.tongueTimer > this.tongueInterval) {
                this.tongueOut = !this.tongueOut;
                this.tongueTimer = 0;
            }
        }
        this.draw();
    }
}

class Food {
    constructor() {
        this.pos = new helpers.Vec(
            ~~(Math.random() * cells) * cellSize,
            ~~(Math.random() * cells) * cellSize
        );
        this.color = currentHue = `hsl(${~~(Math.random() * 360)}, 100%, 50%)`;
        this.size = cellSize;
    }
    draw() {
        let { x, y } = this.pos;
        CTX.save();
        CTX.shadowColor = this.color;
        CTX.shadowBlur = 10;
        CTX.fillStyle = this.color;
        CTX.beginPath();
        CTX.arc(x + this.size / 2, y + this.size / 2, this.size / 2 - 1, 0, 2 * Math.PI);
        CTX.fill();

        CTX.shadowBlur = 0;
        CTX.fillStyle = "brown";
        CTX.fillRect(x + this.size / 2 - 1, y + 2, 2, 5);

        CTX.fillStyle = "green";
        CTX.beginPath();
        CTX.ellipse(x + this.size / 2 + 4, y + 4, 4, 3, Math.PI / 4, 0, 2 * Math.PI);
        CTX.fill();

        CTX.restore();
    }
    spawn() {
        let randX = Math.floor(Math.random() * cells) * cellSize;
        let randY = Math.floor(Math.random() * cells) * cellSize;

        // Ensure food doesn't spawn outside the playable area
        randX = Math.min(randX, W - cellSize);
        randY = Math.min(randY, H - cellSize);

        for (let path of snake.history) {
            if (helpers.isCollision(new helpers.Vec(randX, randY), path)) {
                return this.spawn();
            }
        }
        this.color = currentHue = `hsl(${helpers.randHue()}, 100%, 50%)`;
        this.pos = new helpers.Vec(randX, randY);
    }
}

class Particle {
    constructor(pos, color, size, vel) {
        this.pos = pos;
        this.color = color;
        this.size = Math.abs(size / 2);
        this.ttl = 0;
        this.gravity = -0.1;
        this.vel = vel;
    }
    draw() {
        let { x, y } = this.pos;
        CTX.globalAlpha = 1 - (this.ttl / 50);
        CTX.fillStyle = this.color;
        CTX.globalCompositeOperation = "source-over";
        CTX.beginPath();
        CTX.arc(x, y, this.size, 0, 2 * Math.PI);
        CTX.fill();
        CTX.globalAlpha = 1;
    }
    update() {
        this.draw();
        this.size -= 0.2;
        this.ttl += 1;
        this.pos.add(this.vel);
        this.vel.y -= this.gravity;
    }
}

class Light {
    constructor() {
        this.pos = new helpers.Vec(Math.random() * W, Math.random() * H);
        this.vel = new helpers.Vec((Math.random() - 0.5) * 2, (Math.random() - 0.5) * 2);
        this.radius = Math.random() * 2 + 1;
        this.hue = Math.random() * 360;
    }

    update() {
        this.pos.add(this.vel);
        if (this.pos.x < 0 || this.pos.x > W) this.vel.x *= -1;
        if (this.pos.y < 0 || this.pos.y > H) this.vel.y *= -1;
    }

    draw() {
        CTX.beginPath();
        let gradient = CTX.createRadialGradient(this.pos.x, this.pos.y, 0, this.pos.x, this.pos.y, this.radius * 5);
        gradient.addColorStop(0, `hsla(${this.hue}, 100%, 50%, 0.3)`);
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
        CTX.fillStyle = gradient;
        CTX.arc(this.pos.x, this.pos.y, this.radius * 5, 0, Math.PI * 2);
        CTX.fill();
    }
}

class Meteor {
    constructor() {
        this.size = cellSize;
        this.reset();
    }

    isOutOfBounds() {
        return this.pos.x < -this.size || this.pos.x > W + this.size ||
               this.pos.y < -this.size || this.pos.y > H + this.size;
    }

    reset() {
        const side = Math.floor(Math.random() * 4);
        switch(side) {
            case 0: // Top
                this.pos = new helpers.Vec(Math.random() * W, 0);
                this.vel = new helpers.Vec((Math.random() - 0.5) * 4, Math.random() * 2 + 1);
                break;
            case 1: // Right
                this.pos = new helpers.Vec(W, Math.random() * H);
                this.vel = new helpers.Vec(-(Math.random() * 2 + 1), (Math.random() - 0.5) * 4);
                break;
            case 2: // Bottom
                this.pos = new helpers.Vec(Math.random() * W, H);
                this.vel = new helpers.Vec((Math.random() - 0.5) * 4, -(Math.random() * 2 + 1));
                break;
            case 3: // Left
                this.pos = new helpers.Vec(0, Math.random() * H);
                this.vel = new helpers.Vec(Math.random() * 2 + 1, (Math.random() - 0.5) * 4);
                break;
        }
        this.hue = Math.random() * 360;
    }

    update() {
        this.pos.add(this.vel);
    }

    draw() {
        CTX.fillStyle = `hsl(${this.hue}, 100%, 50%)`;
        CTX.shadowColor = `hsl(${this.hue}, 100%, 50%)`;
        CTX.shadowBlur = 10;
        CTX.beginPath();
        CTX.arc(this.pos.x + this.size / 2, this.pos.y + this.size / 2, this.size / 2, 0, 2 * Math.PI);
        CTX.fill();

        CTX.strokeStyle = `hsl(${this.hue}, 100%, 70%)`;
        CTX.lineWidth = 2;
        CTX.beginPath();
        CTX.moveTo(this.pos.x + this.size / 2, this.pos.y + this.size / 2);
        CTX.lineTo(this.pos.x + this.size / 2 - this.vel.x * 3, this.pos.y + this.size / 2 - this.vel.y * 3);
        CTX.stroke();
    }

    checkCollision(snakeHead) {
        return helpers.isCollisionCircle(
            this.pos,
            snakeHead,
            this.size / 2,
            cellSize / 2
        );
    }
}

function updateMeteors() {
    const currentTime = Date.now();

    meteors = meteors.filter(meteor => {
        meteor.update();
        if (meteor.checkCollision(snake.pos)) {
            isGameOver = true;
        }
        return !meteor.isOutOfBounds();
    });

    meteorSpawnTimers.forEach((spawnTime, index) => {
        if (currentTime - spawnTime >= METEOR_SPAWN_DELAY) {
            spawnMeteor();
            meteorSpawnTimers[index] = currentTime;
        }
    });
}

function incrementScore() {
    score++;
    dom_score.innerText = `Score: ${score.toString().padStart(2, "0")}`;

    if (score % 10 === 0) {
        snake.speedLevel++;
    }

    if (score === 3 && meteorSpawnTimers.length === 0) {
        shouldSpawnMeteors = true;
        meteorSpawnTimers.push(Date.now());
    }

    if (score >= 5 && score % 5 === 0) {
        meteorSpawnTimers.push(Date.now());
    }

    if (isMusicOn) {
        let eatSound = new Audio('file:///android_asset/ding.mp3');
        eatSound.play().catch(e => console.log("Audio play failed:", e));
    }
}

function particleSplash() {
    for (let i = 0; i < splashingParticleCount; i++) {
        let vel = new helpers.Vec(Math.random() * 6 - 3, Math.random() * 6 - 3);
        let position = new helpers.Vec(food.pos.x, food.pos.y);
        particles.push(new Particle(position, currentHue, food.size, vel));
    }
}

function clear() {
    CTX.clearRect(0, 0, W, H);
}

function initialize() {
    CTX.imageSmoothingEnabled = false;
    KEY.listen();
    cellsCount = cells * cells;
    cellSize = W / cells;
    snake = new Snake();
    food = new Food();
    dom_startPauseButton.addEventListener("click", toggleStartPause, false);
    document.getElementById('submitScore').addEventListener('click', submitScore);
    document.getElementById('closeLeaderboard').addEventListener('click', closeLeaderboard);
    document.getElementById('musicToggle').addEventListener('click', toggleMusic);
    for (let i = 0; i < NUM_LIGHTS; i++) {
        lights.push(new Light());
    }
    meteors = [];
    meteorCount = 0;
    shouldSpawnMeteors = false;
    drawInitialState();

    const controlArea = document.getElementById('controlArea');
    let activeButton = null;

    function getButtonFromPoint(x, y) {
        const buttons = document.querySelectorAll('.control-btn');
        const padding = cellSize; // Increase this value to make the touch area larger

        for (let button of buttons) {
            const rect = button.getBoundingClientRect();
            if (x >= rect.left - padding && x <= rect.right + padding &&
                y >= rect.top - padding && y <= rect.bottom + padding) {
                return button;
            }
        }
        return null;
    }

    function handleTouch(e) {
        e.preventDefault();
        if (!isGameStarted || isPaused) return;

        const touch = e.touches[0];
        const button = getButtonFromPoint(touch.clientX, touch.clientY);

        if (button && button !== activeButton) {
            if (activeButton) {
                activeButton.classList.remove('active');
            }
            activeButton = button;
            activeButton.classList.add('active');
            KEY.setLastPressed(button.dataset.direction);
        } else if (!button && activeButton) {
            activeButton.classList.remove('active');
            activeButton = null;
            KEY.resetState();
        }
    }

    controlArea.addEventListener('touchstart', handleTouch, { passive: false });
    controlArea.addEventListener('touchmove', handleTouch, { passive: false });

    controlArea.addEventListener('touchend', function(e) {
        e.preventDefault();
        if (activeButton) {
            activeButton.classList.remove('active');
        }
        activeButton = null;
        KEY.resetState();
    }, { passive: false });

    document.addEventListener('keydown', function(e) {
        if (!isGameStarted || isPaused) return;
        switch(e.key) {
            case 'ArrowUp':
            case 'ArrowDown':
            case 'ArrowLeft':
            case 'ArrowRight':
                KEY.setLastPressed(e.key);
                break;
        }
    });

    document.addEventListener('keyup', function(e) {
        if (e.key === KEY.lastPressed) {
            KEY.setLastPressed(null);
        }
    });
}

function toggleStartPause() {
    if (!isGameStarted) {
        startGame();
    } else {
        togglePause();
    }
}

function startGame() {
    isGameStarted = true;
    isPaused = false;
    dom_startPauseButton.innerHTML = 'Pause';
    reset();
    startBackgroundMusic();
    startTimer();
    loop();
}

function togglePause() {
    isPaused = !isPaused;
    if (isPaused) {
        dom_startPauseButton.innerHTML = 'Resume';
        stopBackgroundMusic();
        pauseTimer();
    } else {
        dom_startPauseButton.innerHTML = 'Pause';
        startBackgroundMusic();
        resumeTimer();
        loop();
    }
}

function drawInitialState() {
    clear();
    helpers.drawGrid();
    snake.draw();
    food.draw();
    for (let light of lights) {
        light.draw();
    }
}

function spawnMeteor() {
    meteors.push(new Meteor());
}

function updateMeteorCount() {
    if (score >= 9) {
        meteorCount = Math.floor((score - 9) / 9) * 2 + 1;
    } else {
        meteorCount = 0;
    }
}

function drawMeteors() {
    meteors.forEach(meteor => meteor.draw());
}

function loop() {
    clear();
    if (!isGameOver && !isPaused) {
        requestID = setTimeout(loop, 1000 / 60);
        helpers.drawGrid();
        for (let light of lights) {
            light.update();
            light.draw();
        }
        food.draw();
        for (let p of particles) {
            p.update();
        }
        snake.update();
        if (shouldSpawnMeteors) {
            updateMeteors();
            drawMeteors();
        }
        particles = particles.filter(p => p.size > 0.1);
    } else if (isGameOver) {
        clear();
        gameOver();
    }
}

let backgroundMusic = new Audio('file:///android_asset/background_music.mp3');
backgroundMusic.loop = true;
let isMusicOn = true;

function toggleMusic() {
    isMusicOn = !isMusicOn;
    if (isMusicOn) {
        startBackgroundMusic();
        document.getElementById('musicToggle').textContent = 'üîä';
    } else {
        stopBackgroundMusic();
        document.getElementById('musicToggle').textContent = 'üîá';
    }
}

function startBackgroundMusic() {
    if (isMusicOn && isGameStarted && !isPaused) {
        backgroundMusic.play().catch(e => console.log("Audio play failed:", e));
    }
}

function stopBackgroundMusic() {
    backgroundMusic.pause();
}

let leaderboard = JSON.parse(localStorage.getItem('snakeLeaderboard')) || [];
function showGameOver() {
    document.getElementById('gameOver').style.display = 'block';
    document.getElementById('finalScore').textContent = score;
    document.getElementById('finalTime').textContent = formatTime(elapsedTime);
}

function submitScore() {
    let playerName = document.getElementById('playerName').value.trim() || 'Anonymous';
    playerName = playerName.substring(0, 20);
    leaderboard.push({name: playerName, score: score, time: elapsedTime});
    leaderboard.sort((a, b) => b.score - a.score || a.time - b.time);
    leaderboard = leaderboard.slice(0, 10);
    localStorage.setItem('snakeLeaderboard', JSON.stringify(leaderboard));
    showLeaderboard();
}

function showLeaderboard() {
    let leaderboardList = document.getElementById('leaderboardList');
    leaderboardList.innerHTML = '';
    leaderboard.forEach((entry, index) => {
        let row = document.createElement('div');
        row.className = 'leaderboard-row';

        row.innerHTML =
            '<div class="leaderboard-cell">' + (index + 1) + '.</div>' +
            '<div class="leaderboard-cell">' + entry.name + '</div>' +
            '<div class="leaderboard-cell">' + entry.score + '</div>' +
            '<div class="leaderboard-cell">' + formatTime(entry.time) + '</div>';
        leaderboardList.appendChild(row);
    });
    document.getElementById('gameOver').style.display = 'none';
    document.getElementById('leaderboard').style.display = 'block';
}

function closeLeaderboard() {
    document.getElementById('leaderboard').style.display = 'none';
    reset();
    drawInitialState();
    dom_startPauseButton.innerHTML = 'Start';
}

function reset() {
    score = 0;
    dom_score.innerText = `Score: 00`;
    snake = new Snake();
    food.spawn();
    KEY.resetState();
    isGameOver = false;
    clearTimeout(requestID);
    resetTimer();
    lights = [];
    for (let i = 0; i < NUM_LIGHTS; i++) {
        lights.push(new Light());
    }
    snake.speedLevel = 0;
    meteors = [];
    meteorSpawnTimers = [];
    shouldSpawnMeteors = false;
}

function notifyGameOver() {
    if (window.Android) {
        window.Android.onGameOver();
    }
}

function gameOver() {
    maxScore ? null : (maxScore = score);
    score > maxScore ? (maxScore = score) : null;
    window.localStorage.setItem("maxScore", maxScore);
    stopBackgroundMusic();
    stopTimer();
    isGameStarted = false;
    dom_startPauseButton.innerHTML = 'Start';
    notifyGameOver(); // Add this line
    showGameOver();
}

function startTimer() {
    startTime = Date.now() - elapsedTime;
    timerInterval = setInterval(updateTimer, 1000);
}

function pauseTimer() {
    clearInterval(timerInterval);
}

function resumeTimer() {
    startTime = Date.now() - elapsedTime;
    timerInterval = setInterval(updateTimer, 1000);
}

function stopTimer() {
    clearInterval(timerInterval);
}

function resetTimer() {
    clearInterval(timerInterval);
    elapsedTime = 0;
    updateTimerDisplay();
}

function updateTimer() {
    elapsedTime = Date.now() - startTime;
    updateTimerDisplay();
}

function updateTimerDisplay() {
    dom_timer.textContent = formatTime(elapsedTime);
}

function formatTime(ms) {
    let seconds = Math.floor(ms / 1000);
    let minutes = Math.floor(seconds / 60);
    seconds = seconds % 60;
    return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
}

function createSparkles() {
    const sparkleContainer = document.createElement('div');
    sparkleContainer.className = 'sparkle-container';
    sparkleContainer.style.position = 'fixed';
    sparkleContainer.style.top = '0';
    sparkleContainer.style.left = '0';
    sparkleContainer.style.width = '100%';
    sparkleContainer.style.height = '100%';
    sparkleContainer.style.overflow = 'hidden';
    sparkleContainer.style.pointerEvents = 'none';
    sparkleContainer.style.zIndex = '0';
    document.body.appendChild(sparkleContainer);

    const sparkleCount = 25;  // Adjust this number for more or fewer sparkles

    for (let i = 0; i < sparkleCount; i++) {
        const sparkle = document.createElement('div');
        sparkle.className = 'sparkle';
        sparkle.style.left = `${Math.random() * 100}%`;
        sparkle.style.top = `${Math.random() * 100}%`;
        sparkle.style.animationDelay = `${Math.random() * 2}s`;
        sparkleContainer.appendChild(sparkle);
    }
}

function resizeCanvas() {
    const canvas = document.querySelector('canvas');
    const container = document.getElementById('canvas');
    const containerWidth = container.clientWidth;
    const containerHeight = container.clientHeight;

    cellSize = Math.floor(Math.min(containerWidth, containerHeight) / cells);

    W = canvas.width = cells * cellSize;
    H = canvas.height = cells * cellSize;

    // Reinitialize game objects if necessary
    if (snake) {
        snake.size = cellSize;
        snake.pos = new helpers.Vec(Math.floor(W / 2 / cellSize) * cellSize, Math.floor(H / 2 / cellSize) * cellSize);
        snake.history = [new helpers.Vec(snake.pos.x, snake.pos.y)];
    }
    if (food) {
        food.size = cellSize;
        food.spawn();
    }

    // Reinitialize lights
    lights = [];
    for (let i = 0; i < NUM_LIGHTS; i++) {
        lights.push(new Light());
    }
}

function detectDevice() {
    const ua = navigator.userAgent;
    if (/(tablet|ipad|playbook|silk)|(android(?!.*mobi))/i.test(ua)) {
        return "tablet";
    }
    if (/Mobile|Android|iP(hone|od)|IEMobile|BlackBerry|Kindle|Silk-Accelerated|(hpw|web)OS|Opera M(obi|ini)/.test(ua)) {
        return "mobile";
    }
    return "desktop";
}

// Add this function to your existing <script> section
function makeDraggable(element) {
    let isDragging = false;
    let startX, startY, startLeft, startTop;

    const handle = document.createElement('div');
    handle.className = 'controller-handle';
    element.appendChild(handle);

    handle.addEventListener('mousedown', startDrag);
    handle.addEventListener('touchstart', startDrag);

    document.addEventListener('mousemove', drag);
    document.addEventListener('touchmove', drag);

    document.addEventListener('mouseup', stopDrag);
    document.addEventListener('touchend', stopDrag);

    function startDrag(e) {
        isDragging = true;
        if (e.type === 'touchstart') {
            startX = e.touches[0].clientX;
            startY = e.touches[0].clientY;
        } else {
            startX = e.clientX;
            startY = e.clientY;
        }
        startLeft = element.offsetLeft;
        startTop = element.offsetTop;
        e.preventDefault();
    }

    function drag(e) {
        if (!isDragging) return;
        let clientX, clientY;
        if (e.type === 'touchmove') {
            clientX = e.touches[0].clientX;
            clientY = e.touches[0].clientY;
        } else {
            clientX = e.clientX;
            clientY = e.clientY;
        }
        let deltaX = clientX - startX;
        let deltaY = clientY - startY;

        let newLeft = startLeft + deltaX;
        let newTop = startTop + deltaY;

        // Ensure the controller stays within the screen boundaries
        newLeft = Math.max(0, Math.min(newLeft, window.innerWidth - element.offsetWidth));
        newTop = Math.max(0, Math.min(newTop, window.innerHeight - element.offsetHeight));

        element.style.left = `${newLeft}px`;
        element.style.top = `${newTop}px`;
        element.style.bottom = 'auto';
        element.style.transform = 'none';
        e.preventDefault();
    }

    function stopDrag() {
        isDragging = false;
    }
}


// Modify the applyDeviceSpecificStyles function
function applyDeviceSpecificStyles() {
    const deviceType = detectDevice();
    const controller = document.querySelector('.controller');

    if (deviceType === "tablet") {
        controller.style.width = "30vmin";
        controller.style.height = "30vmin";
    } else if (deviceType === "mobile") {
        controller.style.width = "40vmin";
        controller.style.height = "40vmin";
    } else {
        // Reset to default styles for desktop
        controller.style.width = "40vmin";
        controller.style.height = "40vmin";
    }

    // Make the controller draggable
    makeDraggable(controller);
}

// Call resizeCanvas and applyDeviceSpecificStyles on window resize
window.addEventListener('resize', () => {
    resizeCanvas();
    applyDeviceSpecificStyles();
});

// Call resizeCanvas, initialize, createSparkles, and applyDeviceSpecificStyles on initial load
window.addEventListener('load', () => {
    resizeCanvas();
    initialize();
    createSparkles();
    applyDeviceSpecificStyles();
});
</script>
</body>
</html>